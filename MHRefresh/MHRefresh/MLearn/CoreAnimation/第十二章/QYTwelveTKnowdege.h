//
//  QYTwelveTKnowdege.h
//  MHRefresh
//
//  Created by panle on 2018/5/21.
//  Copyright © 2018年 developer. All rights reserved.
//

#import <Foundation/Foundation.h>

@interface QYTwelveTKnowdege : NSObject

@end

/**
 第十二章 性能调优
 
 */

/**
 12.1.1 CPU VS GPU
 
 关于绘图和动画有两种处理的方式：CPU:(中央处理器)和GPU(图形处理器)   CPU所做的工作都是软件的层面，GPU所做的工作都是硬件层面
 
 总的来说 我们可以用软件做什么事，但是对于图像处理，通常用硬件会更快。因为GPU使用图像对高度并行浮点运算做了优化。由于某些原因，我们想尽可能把屏幕渲染的工作交给硬件去处理。问题在于GPU并没有无限制处理心梗，而且一旦资源用完的话，心梗就会开始下降了。
 
 大多数动画心梗优化都是关于智能利用GPU、CPU,使得它们都不会超出负荷。
 
 12.1.2 动画的舞台
 
 Core Animation 处在iOS的核心地位：应用内和应用间都会用到它。一个简单的动画可能同步显示多个app的内容
 
 动画和屏幕上组合的图层实际上被一个单独的进程管理，而不是你的应用程序，这个进程就是所谓的渲染服务。在iOS5和之前的版本是SpringBoard进程（同时管理着iOS的主屏）。
 
 在运行一段动画的时候，这个过程会被四个分离的阶段被打破
 布局---这是准备你的视图/图层的层级关系，以及设置图层属性的阶段。
 显示---这是图层的寄宿图片被绘制的解读那。绘制有可能涉及你的 draw:和 drawLayer:inContext:方法的调用路径。
 准备---这是Core Animation准备发送动画数据到渲染服务的极端。这同时也是Core Animation将要执行一些别的事务例如解码动画过程中将要显示的图片的时间点。
 提交---这是最后的阶段，Core animation 打包所有图层和动画属性，然后通过IPC(内部处理通信)发送到渲染服务进行显示。
 
 但是这些阶段仅仅发生在你的应用程序之内，在动画在屏幕上显示之前仍然有着更多的工作。一旦打包的图层和动画到达渲染服务进程，它们会被反序列化来形成另一个叫做渲染书的图层树。使用这个树状结构，渲染服务队动画的每一帧作出如下动作
 1.对所有的图层属性计算中间值，设置OpenGL几何形状来执行渲染。
 2.在屏幕上渲染可见的三角形
 
 所以一共有6个阶段：最后两个阶段在动画过程中不停的重复。前5个解读那都在软件层面处理（通过CPU），只有最后一个被GPU执行。而且，你只能控制两个阶段，布局和显示。
 
 在布局和显示阶段，你可以决定哪些交由CPU执行，哪些交给GPU去做
 
 12.1.2 GPU相关的操作
 
 GPU为一个具体的任务做了优化，它用来采集图片和形状（三角形），运行变换，应用纹理和混合然后把他们输送到屏幕上。现代iOS设备上可编程的GPU在这些操作的执行上有很大的灵活性，但是Core Animation 并没有直接的接口。
 
 宽泛的来说，大部分的CAlayer属性都是GPU来绘制，比如如果你设置图层北京或者边框的颜色，那么这些可以通过着色的三角板实时绘制出来，如果对一个contents属性设置一张图片，然后裁剪它-它就会被纹理的三角形绘制出来，而不需要软件层面的任何绘制。
 
 但是有一个事情会降低（GPU）的图层绘制。
 1.太多的集合结构，这发生在需要太多的三角板来做变换，以及对处理器的栅格化的时候。现代iOS设备的图形芯片可以处理几百万个三角板，所以在Core Animation中集合结构并不是GPU的瓶颈所在，但由于图层在显示之前通过IPC发送到渲染服务器的时候，太多的图层就会引起CPU的瓶颈。这就限制了一次展示的图层个数
 
 2.重绘 主要由重叠的半透明图层引起。GPU的填充比率（用颜色填充像素的比率）是有限的。所以需要避免重绘（每一帧用相同的像素填充多次）的发生，GPU会应对重绘。
 
 3.离屏重绘  这发生在当不能直接在屏幕上绘制，并且必须绘制到离屏图片的上下文中的时候，离屏绘制发生在基于CPU或者是GPU的渲染，或者是为离屏图片分配额外内存，以及切换绘制上下文，这些都会降低GPU性能。对于特定图层效果的使用，比如圆角、图层遮罩、阴影或者是图层光栅化都会强制Core Animation 提前渲染图层的离屏绘制。但这不意味着你需要避免使用这些效果，只是要明白这回带来性能的负面影响。
 
 4. 过大的图片  如果视图超出GPU支持的2048*2048或者4096*4096尺寸的纹理，就必须要用CPU在图层每次显示之前对图片预处理，同样也会降低性能。
 
 
 12.1.3 CPU相关的操作

 大多数工作在CoreAnimation都发生在动画开始之前，这意味着它不会影响到帧率，所以很好，但是他会延迟动画开始的时间，让你的界面看起来会比较迟钝。
 
 
 以下CPU的操作都会延迟动画的开始时间
 
 1. 布局计算 - 如果你的视图层级过于复杂，当视图需要呈现或者修改的时候，计算图层帧率就会消耗一部分时间。
 
 2. 视图拦加载 - iOS只会当视图控制器的视图显示到屏幕上时才会加载它。这对内存使用和程序启动时间很有好处，但是当呈现到屏幕之前，按下按钮导致的许多工作都不能被及时响应，比如控制器从数据库中获取数据，或者视图从一个nib文件中加载，或者涉及IO的图片显示，都会比CPU正常操作慢很多。
 
 3. Core Graphics绘制 - 如果对视图实现了-drawRect:方法 或者drawlayer:inContext方法，那么在绘制任何东西之前都会产生一个巨大的性能开销。为了支持对图层任意内容的绘制，CoreAnimation 必须创阿金一个内存中等小的寄宿图片，然后一旦绘制结束之后，必须把图片数据通过IPC传到渲染服务器，在此基础上，CoreGraphics绘制就会变得十分缓慢，所以在一个对性能十分挑剔的场景下这样做十分不好。
 
 4. 解压图片 - PNG和JPRG压缩之后图片的文件会比同质量的位图小很多，但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸，（通常等于 图片 宽 * 长 * 4个字节），为了节省内存，iOS通常直到真正绘制的时候才去解码图片。根据你的加载图片的方式，第一次对图层内容赋值的时候（直接或间接使用UIImageView）或者把它绘制到CoreGraphics中，都需要对它解压，这样的话，对于一个较大的图片，都会占用一定的时间。
 
 当图层被打包成功后，发送到渲染服务器之后，CPU仍会做如下工作，为了显示屏幕上的图层，CoreAnimation必须对渲染树种的每个可见图层通过OpenGL循环转换成纹理三角板。由于GPU并不知晓CoreAnimation图层的任何结构，所以必须要CPU做这些事情，这里CPU涉及的工作和图层个数成正比，所以如果在你的层级关系中有太多的图层，就会导致CPU每一帧的渲染，即使这些事情不是你的应用程序可以控制的
 */


/**
 12.2.1  I/O操作
 
 上下文中的I/O指的是闪存或者网络接口的硬件访问。一些动画可能需要从闪存来加载。典型的例子就是两个视图控制器之间的过渡效果，这就需要从一个nib文件或者是它的内容中懒加载，或者一个旋转的图片，可能内存中尺寸太大，需要动态滚动来加载
 
 IO比内存访问更慢，所以如果动画涉及到IO，就是一个大问题，总的来说，这就需要使用聪明但尴尬的技术，也就是多线程，缓存和投机加载（提前加载当前不需要的资源，但是之后可能用到）
 */


/**
 12.3.1  测量而不是猜测
 
 根据性能相关的知识写出代码不同于仓促的优化
 
 12.3.2 测试真机而不是模拟器
 
 当你开始做一些心梗方面的工作时，一定要在真机上测试，而不是模拟器。模拟器不能提供准确的真机性能参数
 
 模拟器运行在mac上，mac的CPU往往比iOS设备要快。
 
 性能测试一定要用发布配置，而不是debug模式。因为当用发布环境打包的时候，编译器会银如意一系列提高性能的优化，例如去掉调试符号或者移除并重新组织代码。
 
 最好在你支持的设备中性能最差的设备上测试
 
 
 12.3.2 保持一致的帧率
 
 为了做到动画的平滑，你需要以60FPS（帧每秒）的速度运行，以同步屏幕刷新速率运行。通过基于NSTimer或者CADisplayLink的动画你可以降低到30FPS,而且效果还不错，如果不保持60FPS的速率，就可能随机丢帧，影响到体验。
 
 你可以使用CADisplayLink来测量帧率，然后在屏幕上显示出来
 */
