//
//  QYTFourteenKnowdege.h
//  MHRefresh
//
//  Created by panle on 2018/6/5.
//  Copyright © 2018年 developer. All rights reserved.
//

#import <Foundation/Foundation.h>

@interface QYTFourteenKnowdege : NSObject

@end

/**
 15 图像IO
 */


/**
 15.0.1 加载和潜伏
 
 绘图实际消耗的时间通畅并不是影响性能的因素。图片消耗很大一部分内存，而且不大可能把需要显示的图片都留在内存中，所以需要在应用运行的时候周期性的加载图片
 
 图片文件加载的速度被CPU和IO（输入输出）同时影响。iOS设备上的闪存已经比传统硬盘快很多了，但仍然比RAM慢将近200倍左右，这就需要很小心的管理加载，来避免延迟。
 
 只要有可能，试着在程序生命周期不易察觉的时候来加载图片，例如启动，或者在屏幕切换的过程中。按下安妮和按钮响应事件之间最大的延迟大概就是200ms，这比动画每一帧切换的16ms小得多。你可以在程序首次启动的时候加载图片，但是如果20s内无法启动程序的话，iOS检测计时器就会终止你的应用。
 
 15.0.2 线程加载
 
 加载大图会消耗很长时间  造成滑动的不流畅性  滑动动画会在runloop中更新，所以会有更多运行在渲染服务进程中CPU相关的性能问题
 
 提升性能可以在另一个线层中加载图片  这并不能降低实际的加载时间 但是主线程能够有时间做一些别的事情  比如响应用户输入  并不十分有效
 
 15.0.3 GCD和NSOperationQueue
 
 两者都能为我们提供队列闭包块来在线程中按一定顺序来执行。
 
 15.0.4 延迟解压
 
 一旦图片文件被加载就必须进行解码，解码过程是一个相当复杂的任务，需要消耗非常多的时间。解码后的图片将同样使用相当大的内存。
 
 当加载图片的时候  iOS通畅会延迟解压图片的时间，知道加载到内存后，这就需要在准备绘制图片的时候影响性能，因为需要在绘制之前进行解压
 
 最简单的方法就是使用UIImage的+imageNamed:方法避免延时加载。不像+imageWithContentsOfFile:（和其他别的UIImage加载方法），这个方法会在加载图片之后立刻进行解压（就和本章之前我们谈到的好处一样）。问题在于+imageNamed:只对从应用资源束中的图片有效，所以对用户生成的图片内容或者是下载的图片就没法使用了。
 
 另外一种立刻加载图片的方法就是把它设置成图层内容  或者是 UIImageView 的  image 属性  不幸的是，这又需要在主线程运行  所以不会对性能有所提升
 
 NSInteger index = indexPath.row;
 NSURL *imageURL = [NSURL fileURLWithPath:self.imagePaths[index]];
 NSDictionary *options = @{(__bridge id)kCGImageSourceShouldCache: @YES};
 CGImageSourceRef source = CGImageSourceCreateWithURL((__bridge CFURLRef)imageURL, NULL);
 CGImageRef imageRef = CGImageSourceCreateImageAtIndex(source, 0,(__bridge CFDictionaryRef)options);
 UIImage *image = [UIImage imageWithCGImage:imageRef];
 CGImageRelease(imageRef);
 CFRelease(source);
 
 这样就可以使用kCGImageSourceShouldCache来创建图片，强制图片立刻解压，然后在图片的生命周期保留解压后的版本。
 

 最后一种方式就是使用UIKit加载图片，但是会立刻绘制到CGContxet 中去。  图片必须要在绘制之前解压  所以就强制了解压的及时性，这样的好处在于绘制图片可以在后台线程执行，而不会阻塞UI
 
 有两种方式可以为强制解压提前渲染图片：
 
 将图片的一个像素绘制成一个像素大小的CGContext.这样仍然会解压整张图片，但是绘制本身并没有消耗任何时间。这样的好处在于加载的图片并不会在特定的设备上为绘制做优化，所以可以在任何时间点绘制出来。同样iOS也就可以丢弃解压后的图片来节省内存了
 
 将整张图片绘制到CGCOntext中，丢弃原始的图片，并且用一个从上下文内容中新的图片来代替。这样比绘制单一这像素那样需要更加复杂的计算，但是因此产生的图片将会为绘制做优化，而且由于原始压缩图片被抛弃了，iOS就不能够随时丢弃任何解压后的图片来节省内存了
 
 15.0.5 分辨率交换
 
 视网膜分辨率代表了人的肉眼在正常视觉距离能够分辨的最小像素尺寸，但是这只能应用于静态像素。当观察一个移动图片时，你的眼睛就会对细节不敏感，于是一个低分辨率的图片和视网膜质量的图片没什么区别了。
 
 如果需要快速加载和显示移动大图，简单的方法就是欺骗人眼，在移动传送器的时候显示一个小图（或者低分辨率）， 然后当停止的时候再换成大图。这意味着我们需要对每张图片存储两份不同分辨率的副本，但是幸运的是，由于需要同时支持Retina和非Retina设备，本来这就是普遍需要做到的。
 
 如果从远程源或者用户的相册加载没有可用的低分辨率版本图片，那就可以动态将大图绘制成较小的CGContext，然后存储到某处以备复用。
 
 为了做到图片交换，我们需要利用UIScrollView的一些实现协议委托方法
 
 - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;
 - (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView;
 
 你可以使用这几个方法来检测传送器是否停止滚动，然后加载高分辨率图片，只要高分辨率图片和低分辨率图片尺寸颜色一致，你就会很难察觉到替换的过程。
 
 */


/**
 15.1.0 缓存
 
 如果需要很多张图片要显示  最好不要提前把所有都加载进来，而是应该当移除屏幕后立刻销毁。通过选择性的缓存，你就可以避免来回滚动时图片重复性的加载了
 
 缓存其实很简单  就是存储昂贵计算后的结果在内存中，以便后续使用 这样访问起来很快  问题在于缓存本质上是一个权衡过程。为了提升性能而消耗了内存  但是由于内存是一个非常宝贵的资源  所以不能把所有东西都做缓存
 
 
 +imageNamed: 方法
 
 方法加载图片有个好处就是可以立刻解压图片而不用等到绘制的时候。但是这个方法有一个显著的好处就是 它在内存中自动缓存了解压后的图片，即使你自己没有保留对它的任何引用
 
 对于iOS应用那些主要的图片  使用方法加载图片是最简单有效的方式
 
 该方法并不是适用于任何情况。  它为用户界面做了优化，但是这并不是对应用程序需要显示的所有类型的图片都适用。有些时候 你需要实现自己的缓存机制。
 
 该方法仅仅适用于在应用程序资源目录下的图片，如果对照片这种大图也用这种缓存，那么iOS系统很可能会移除这些图片来节省内存。那么在切换页面的时候性能就会下降，因为这些图片都需要重新加载。对传送器的图片使用一个单独的缓存机制可以把它和应用图片的生命周期解耦
 
 该方法缓存机制不是公开的  所以并不能很好的控制  例如你没法做到检测图片是否在加载之前就做了缓存  不能够设置缓存大小  当图片没用的时候也不能把它从缓存宏移除
 
 
 15.1.1 自定义缓存
 
 构建一个缓存系统非常困难   计算机中只有两件难事   缓存和命名
 
 选择一个合适的缓存键  作为唯一标识符    如果实时创建图片  通常不太好生成一个字符串来区分别的图片
 
 提前缓存  如果生成和加载数据数据的代价很大  你可能向当第一次用到的时候再去加载和缓存  提前加载的逻辑是应用内在就有的  但是在我们的例子中   这也非常好实现  因为对于一个给定的位置和滚动方向  我们就可以精确地判断出哪一张图片将会出现
 
 缓存失效  如果图片文件发生了变化  比较好的方式是  为图片标记一个时间戳
 
 缓存回收  当内存不够用时  如何判断哪些缓存需要清空   这就需要一个合适的算法
 
 
 15.1.2  NSCache
 
 NSCache 类似于 NSDictionary
 
 可以控制缓存的自定义消耗空间大小
 
 */


/**
 15.2.1 文件格式
 
 图片的加载性能取决于加载大图的时间和解压小图时间的权衡
 
 PNG图片使用的无损压缩算法可以比使用JPEG的图片做到更快的解压，但是由于闪存访问的原因 这些加载的时间并没有什么区别
 
 混合图片
 对于包含透明的图片来说，最好使用压缩透明通道的PNG图片和压缩RGB部分的JPEG图片混合起来加载。这就对任何格式使用了  而且无论从质量还是文件尺寸还是加载性能来说都和PNG和JPEG的图片相近
 
 JPEG 2000
 
 PVRTC
 
 */
